#include "packet.h"
#include <stdio.h>
#include <string.h>
#include <sys/ioctl.h> 
#include <sys/socket.h> 
#include <netinet/in.h> 
#include <net/if.h> 
#include "md5.h"

static packet *_this = 0;
static u_char Nearest[6] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x03 };
static u_char Mine[6] = { 0x00, 0xe0, 0x4c, 0x68, 0x00, 0x30 };			// 我的机器网卡MAC地址
static char username[] = "S1*0****";
static char password[] = "0*****";

// extra data
unsigned char extra_data[] = {
	0xFF, 0xFF, 0x37, 0x77, 0x7F, 0xAF, 0xBA, 0x3D, 0x19, 0x00, 0x00, 0xFC, 0xFF, 0xAF, 0xBA, 0xFD,
	0x7F, 0x04, 0x5F, 0x5F, 0x5F, 0xFD, 0x5A, 0x00, 0x00, 0x13, 0x11,
	// 文件名 8021x.exe
	0x38, 0x30, 0x32, 0x31, 0x78, 0x2E, 0x65, 0x78, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0x04, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x11, 0x01, 0xF5,

	0x1A, 0x28, 0x00, 0x00, 0x13, 0x11, 0x17, 0x22,		// 未知: 68999b866a635577b39dc910ed6bcc03,改变
	0x36, 0x38, 0x39, 0x39, 0x39, 0x62, 0x38, 0x36, 0x36, 0x61, 0x36, 0x33, 0x35, 0x35, 0x37, 0x37,
	0x62, 0x33, 0x39, 0x64, 0x63, 0x39, 0x31, 0x30, 0x65, 0x64, 0x36, 0x62, 0x63, 0x63, 0x30, 0x33,

	0x1A, 0x0C, 0x00, 0x00, 0x13, 0x11, 0x18, 0x06, 0x00, 0x00, 0x00, 0x00,

	0x1A, 0x0E, 0x00, 0x00, 0x13, 0x11, 0x2D, 0x08,		// 网卡MAC: 34-E6-D7-57-4B-59
	0x34, 0xE6, 0xD7, 0x57, 0x4B, 0x59,

	0x1A, 0x18, 0x00, 0x00, 0x13, 0x11, 0x2F, 0x12,		// 未知，随机改变
	0xF8, 0x04, 0x60, 0x89, 0x16, 0x33, 0xA7, 0x9C, 0x16, 0x70, 0xE7, 0x9E, 0xC4, 0x23, 0xC9, 0xC8,

	0x1A, 0x09, 0x00, 0x00, 0x13, 0x11, 0x35, 0x03, 0x01,	// ip获取方式，动态获取，估计。

	0x1A, 0x18, 0x00, 0x00, 0x13, 0x11, 0x36, 0x12,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0x1A, 0x18, 0x00, 0x00, 0x13, 0x11, 0x38, 0x12,
	0xFE, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0xC7, 0x2C, 0xDA, 0xB8, 0x51, 0xAC, 0xA6,

	0x1A, 0x18, 0x00, 0x00, 0x13, 0x11, 0x4E, 0x12,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0x1A, 0x88, 0x00, 0x00, 0x13, 0x11, 0x4D, 0x82,		// 改变
	0x36, 0x63, 0x63, 0x65, 0x32, 0x39, 0x62, 0x62, 0x35, 0x65, 0x35, 0x38, 0x35, 0x37, 0x64, 0x32, // 6cce29bb5e5857d2
	0x61, 0x38, 0x36, 0x32, 0x64, 0x64, 0x36, 0x66, 0x36, 0x66, 0x33, 0x30, 0x65, 0x66, 0x64, 0x62, // a862dd6f6f30efdb
	0x64, 0x66, 0x33, 0x32, 0x34, 0x33, 0x31, 0x34, 0x30, 0x63, 0x35, 0x62, 0x30, 0x36, 0x62, 0x63, // df3243140c5b06bc
	0x61, 0x62, 0x63, 0x61, 0x37, 0x66, 0x31, 0x64, 0x33, 0x39, 0x61, 0x39, 0x30, 0x36, 0x33, 0x34, // abca7f1d39a90634
	0x64, 0x35, 0x36, 0x64, 0x38, 0x37, 0x63, 0x66, 0x30, 0x38, 0x37, 0x64, 0x65, 0x38, 0x66, 0x34, // d56d87cf087de8f4
	0x62, 0x35, 0x36, 0x39, 0x65, 0x62, 0x30, 0x36, 0x37, 0x34, 0x32, 0x33, 0x37, 0x36, 0x30, 0x34, // b569eb0674237604
	0x62, 0x34, 0x32, 0x39, 0x38, 0x65, 0x66, 0x33, 0x61, 0x34, 0x63, 0x66, 0x33, 0x37, 0x30, 0x35, // b4298ef3a4cf3705
	0x33, 0x63, 0x37, 0x30, 0x65, 0x39, 0x65, 0x61, 0x36, 0x39, 0x33, 0x30, 0x30, 0x65, 0x34, 0x37, // 3c70e9ea69300e47

	0x1A, 0x28, 0x00, 0x00, 0x13, 0x11, 0x39, 0x22,		// 服务: unicom
	0x75, 0x6E, 0x69, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1A, 0x48, 0x00, 0x00, 0x13, 0x11, 0x54, 0x42,		// 硬盘序列号: S1D2NYAG401881
	0x53, 0x31, 0x44, 0x32, 0x4E, 0x59, 0x41, 0x47, 0x34, 0x30, 0x31, 0x38, 0x38, 0x31, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0x1A, 0x09, 0x00, 0x00, 0x13, 0x11, 0x62, 0x03, 0x00,
	0x1A, 0x09, 0x00, 0x00, 0x13, 0x11, 0x6B, 0x03, 0x00,
	0x1A, 0x09, 0x00, 0x00, 0x13, 0x11, 0x70, 0x03, 0x40,
	0x1A, 0x1D, 0x00, 0x00, 0x13, 0x11, 0x6F, 0x17,		// 版本名称  RG-SU V4.99.20131213
	0x52, 0x47, 0x2D, 0x53, 0x55, 0x20, 0x56, 0x34, 0x2E, 0x39, 0x39, 0x2E, 0x32, 0x30, 0x31, 0x33,
	0x31, 0x32, 0x31, 0x33, 0x00,

	0x1A, 0x09, 0x00, 0x00, 0x13, 0x11, 0x79, 0x03, 0x02,
	0x1A, 0x11, 0x00, 0x00, 0x13, 0x11, 0x76, 0x0B,		// 备用dns 223.6.6.6
	0x32, 0x32, 0x33, 0x2E, 0x36, 0x2E, 0x36, 0x2E, 0x36
};

static u_char encode(u_char a){
	u_char r = 0;
	for (int i = 0; i < 8; i++){
		r <<= 1;
		r |= a & 0x01;
		a >>= 1;
	}
	return ~r;
}


packet::packet()
	:start_pkt({ 0, 0 }),
	indentity_pkt({ 0, 0 }),
	md5challenge_pkt({ 0, 0 }),
	keepalive_pkt({ 0, 0 })
{
}

packet::~packet()
{
}

packet *packet::getInstance()
{
	if (!_this){
		_this = new packet;
	}

	return _this;
}

void packet::init_eth(_eth_hdr *hdr, u_char *src_mac, u_char *dst_msc)
{
	memcpy(hdr->dstmac, dst_msc, 6);
	memcpy(hdr->srcmac, src_mac, 6);
	hdr->eth_type = htons(0x888e);
}

void packet::init_eapol(eapol_header* e, u_char type, u_short length, u_char version)
{
	e->version = version;
	e->type = type;
	e->length = length;
}

void packet::init(const char *dev)
{
	struct   ifreq   ifreq;
	int sock ;
	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0){
		perror("socket ");
		return;
	}
	strcpy(ifreq.ifr_name, dev);
	if (ioctl(sock, SIOCGIFHWADDR, &ifreq) < 0)
	{
		perror("ioctl ");
		return;
	}
	memcpy(Mine, ifreq.ifr_hwaddr.sa_data, 6);
	printf("init:%s MAC:", dev);

	for (int i = 0; i < 6; i++){
		printf("%.2x", Mine[i]);
		if (i != 5){
			printf("-");
		}
		else {
			printf("\n");
		}
	}
}

void packet::init_start()
{
	if (!start_pkt.data || !start_pkt.len){
	}
	else {
		delete[]start_pkt.data;
		start_pkt.len = 0;
	}

	start_pkt.data = new u_char[18];
	start_pkt.len = 18;

	u_char *pkt = start_pkt.data;
	init_eth((_eth_hdr *)pkt, Mine, Nearest);

	init_eapol((eapol_header*)(pkt + 14), Start, 0);
}

void packet::init_indentity(u_char *dst_mac, u_char id)
{
	if (!indentity_pkt.data || !indentity_pkt.len){
	}
	else {
		delete[]indentity_pkt.data;
		indentity_pkt.len = 0;
	}

	indentity_pkt.data = new u_char[14 + 4 + 5 + sizeof(username)];
	indentity_pkt.len = 14 + 4 + 5 + sizeof(username) - 1;

	u_char *pkt = indentity_pkt.data;
	init_eth((_eth_hdr *)pkt, Mine, dst_mac);

	u_short len = exAp(pkt + 14 + 4, 2, id, 1, (u_char *)username, sizeof(username) - 1);
	init_eapol((eapol_header*)(pkt + 14), Packet, htons(len));
}

void packet::init_md5_challenge(u_char*dst_mac, u_char id, u_char *md5, u_short len)
{
	int psw_len = strlen(password);
	int buf_len = 1 + len + psw_len;
	u_char *buf = new u_char[buf_len];
	// id+psw+md5_value
	buf[0] = id;
	memcpy(&buf[1], password, psw_len);
	memcpy(&buf[1 + psw_len], md5, len);

/*	MD5 calc_md5(buf, buf_len);*/
	u_char *md5_v = ComputeHash(buf, buf_len);
	int md5_ce_len = 1 + 0x10 + strlen(username);
	u_char *md5_ce = new u_char[md5_ce_len];
	eap_md5_challenge *emc = (eap_md5_challenge *)md5_ce;
	emc->v_size = 0x10;
	// show it
	/*	std::cout << calc_md5.toString() << std::endl;*/
/*	memcpy(emc->md5, calc_md5.digest(), 0x10);*/
	memcpy(emc->md5, md5_v, 0x10);
	memcpy(emc->extra_data, username, strlen(username));

	if (!md5challenge_pkt.data || !md5challenge_pkt.len){
	}
	else {
		delete[]md5challenge_pkt.data;
		md5challenge_pkt.len = 0;
	}
	md5challenge_pkt.data = new u_char[14 + 4 + 5 + md5_ce_len + sizeof(extra_data)];
	md5challenge_pkt.len = 14 + 4 + 5 + md5_ce_len + sizeof(extra_data);

	u_char *pkt = md5challenge_pkt.data;
	init_eth((_eth_hdr *)pkt, Mine, dst_mac);

	init_eapol((eapol_header*)(pkt + 14), Packet, htons(
		exAp(pkt + 14 + 4, 2, id, 4, md5_ce, md5_ce_len)));

	init_extra_data(pkt + 14 + 4 + 5 + md5_ce_len);

	delete[]md5_ce;
	delete[]buf;
}

void packet::init_keepalive(u_char*dst_mac, unsigned int key)
{
	if (!keepalive_pkt.data || !keepalive_pkt.len){
	}
	else {
		delete[]keepalive_pkt.data;
		keepalive_pkt.len = 0;
	}

	keepalive_pkt.data = new u_char[14 + 4 + 27];
	keepalive_pkt.len = 14 + 4 + 27;

	u_char *pkt = keepalive_pkt.data;
	init_eth((_eth_hdr *)pkt, Mine, dst_mac);

	unsigned char data[27] = {
		0xFF, 0xFF, 0x37, 0x77, 0x7F, 0x9F,
		0xA5, 0x99, 0xB8, 0x95,		//
		0xFF, 0xFF, 0x37, 0x77, 0x7F, 0x9F,
		0xFF, 0xFF, 0xF7, 0x0B,		//
		0xFF, 0xFF, 0x37, 0x77, 0x7F, 0x3F, 0xFF
	};

	init_eapol((eapol_header*)(pkt + 14), Keepalive, htons(30));
	memcpy(pkt + 18, data, sizeof(data));

	number = 0x102B;
	//printf("key:%ld\n", key);
	ka_key = ntohl(key);
	//printf("ka_key:%ld\n", ka_key);
	// 求反
	u_char *u = (u_char *)&ka_key;
	for (int i = 0; i < 4; i++){
		u[i] = encode(u[i]);
	}
}

void packet::keepalive()
{
	u_char *pkt = keepalive_pkt.data;
	unsigned int dd1 = htonl(ka_key + number);
	unsigned int dd2 = htonl(number++);
	u_char *bt1 = (u_char *)&dd1, *bt2 = (u_char *)&dd2;
	for (int i = 0; i < 4; i++){
		pkt[18 + 6 + i] = encode(bt1[i]);
		pkt[18 + 16 + i] = encode(bt2[i]);
	}
}

u_short packet::exAp(u_char *d, u_char code, u_char id, u_char type, u_char *identity, u_short length)
{
	extensible_auth *ea = (extensible_auth *)d;
	u_short len = length + 5;

	ea->code = code;
	ea->id = id;
	ea->length = htons(len);
	ea->type = type;
	memcpy(ea->identity, identity, length);
	return len;
}

void packet::init_extra_data(u_char *pkt)
{
	memcpy(pkt, extra_data, sizeof(extra_data));
}